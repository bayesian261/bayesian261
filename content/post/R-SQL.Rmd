---
title: "MSQL"
output: html_document
date: "2023-08-26"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# setup of packages

```{r}
library(tidyverse)
library(odbc)
library(DBI)
library(RSQLite)
```
# data for the tutorial

```{r}
## read in the dataset
df <- readr::read_csv("recipe_site_traffic_2212.csv")

## sample 100 observations and select first 3 variables
set.seed(1123)
data1<- df |>
  sample_n(size=25) |> 
  select(1,2,3,6)

## sample 100 observations and select subsequent 3 variables(including the first(ID))
## 
set.seed(1123)
data2<- df |>
  sample_n(size=25) |> 
  select(1,2,4,5,6)

# Create a database
con<-dbConnect(RSQLite::SQLite(), ":memory:")
copy_to(con,data1)
copy_to(con,data2)
```
# Selecting all data in SQL

```{r}
dbGetQuery(con,'SELECT * FROM data2')
```

# Selecting a subset of variables

```{r}
dbGetQuery(con,'SELECT recipe,sugar FROM data2')
```


# Selecting all data in R

```{r}
data2 |> select(everything())
```

# selecting a subset of variables in R

```{r}
data2 |> 
  select(recipe,sugar)
```


# filtering using `WHERE` in SQL

```{r}
dbGetQuery(con,"SELECT * 
                FROM data2 
                WHERE category='Potato'")

```
# filtering in R

```{r}
data2 |> 
  filter(category=="Potato")
```
# filtering using `IN` and `WHERE` in SQL

```{r}
dbGetQuery(con,"SELECT * 
                FROM data2 
                WHERE category IN ('Chicken','Chicken Breast')")
```
# filtering using `%in%`
```{r}
data2 |> 
  filter(category %in% c("Chicken","Chicken Breast"))
```

# `COUNT` and `AS` alias in SQL

+ we use `AS` to rename default name 

```{r}
dbGetQuery(con,"SELECT COUNT(*) AS n FROM data2")
```
# Counting in dplyr

```{r}
data2 |> count()
```
# count filters in SQL
```{r}
dbGetQuery(con,"SELECT COUNT(category) AS n_potato
                FROM data2 
                WHERE category IN ('Chicken Breast','Chicken')")
```
# counting filters in dplyr

```{r}
data2 |> 
  filter(category %in% c("Chicken","Chicken Breast")) |> 
  summarise(n_potato=n())
```

# Updating a database using `dbExecute`

+ categories before

```{r}
data2 |> 
  janitor::tabyl(category)
```
# Updating a database

+ we need to change a category called `Breakfast` to `Breakfast meal`
+ we shall use `REPLACE`

```{r}
dbExecute(con,"UPDATE data2 
               SET category= REPLACE(category,'Breakfast','Breakfast meal')
               WHERE category='Breakfast'")
```
# Querying to check results

```{r}
dbGetQuery(con,"SELECT category, COUNT(category) as n_per_category
                FROM data2
                GROUP BY category")
```

+ we see that `Breakfast` has updated to `Breakfast meal`


## Updating and grouping in R

+ We use `stringr::str_replace` to replace elements in a string variable

```{r}
data2 |> 
  mutate(category=stringr::str_replace(category,"Breakfast","Breakfast meal")) |> 
  group_by(category) |> 
  summarise(n_per_category=n())
```

# Missing data in SQL

+ Use `IS NULL` AND `IS NOT NULL`

```{r}
dbGetQuery(con,"SELECT * 
                FROM data2 
                WHERE Protein IS NULL")
```

```{r}
dbGetQuery(con,"SELECT * 
                FROM data2 
                WHERE Protein IS NOT NULL")

```

# missing values in R

+ use `is.na()` and `!is.na`

```{r}
data2 |> 
  filter(is.na(protein))
```

```{r}
data2 |> 
  filter(!is.na(protein))
```

# How many categories do we have
## select `distinct` items in SQL

```{r}
dbGetQuery(con,"SELECT COUNT(DISTINCT category) AS unique_categories 
                FROM data2")
```
## select distinct in R

+ use `distinct` in R
```{r}
data2 |> 
  distinct(category) |> 
  summarise(unique_categories=n())
  
```
# Advanced filters
## filtering in SQL
```{r}
dbGetQuery(con,"SELECT * 
                FROM data2 WHERE sugar > 1 AND sugar < 5 
                AND category='Breakfast meal'")
```

+ also achieved by using `BETWEEN` and `AND`
```{r}
dbGetQuery(con,"SELECT * 
                FROM data2 
                WHERE sugar BETWEEN 1 AND 5 
                AND category='Breakfast meal'")
```

# In R

```{r}
data2 |> 
  filter(between(sugar,1,5) & category=="Breakfast")
```

# filtering text data

+ use `LIKE`
```{r}
dbGetQuery(con,"SELECT * 
                FROM data2 
                WHERE category LIKE 'Chicken%'")
```

# Filter text in R
+ use `str_like`

```{r}
data2 |> 
  filter(str_like(category,"Chicken%"))
```
# SQL subqueries

+ use data1 and data2 databases for this task
+ the following is just an example and calories in data2 and data1 are the same so the result is the same

```{r}
dbGetQuery(con,"SELECT recipe,sugar,calories 
                FROM data2 
                WHERE calories > 
                          (SELECT AVG(calories) FROM data1)")
```
+ the above is the same as follows in R

```{r}
data2 |> 
  select(recipe,sugar,calories) |> 
  filter(calories>(data1 |> 
           summarise(mean_calories=mean(calories,na.rm=TRUE)) |> 
             pull(mean_calories)))
```

# Joining tables in SQL and R

* Inner Join - only keep observations found in *both* `x` *and* `y`
* Left Join - keep all observations in `x`
* Right Join - keep all observations in `y`
* Full Join - keep *any* observations in `x` *or* `y`

## for this dataset we shall use `INNER JOIN` Alone

### Inner Join

When talking about inner joins, we are only going to keep an observation if it is found in all of the tables we're combining.

```{r}
dbGetQuery(con,"SELECT data2.category,data2.recipe,data2.calories,
                       carbohydrate,protein,sugar 
                FROM data2
                INNER JOIN data1 ON data2.recipe=data1.recipe")
```

## Inner join in R

```{r}
dplyr::inner_join(data1,data2,by=join_by(recipe)) |> 
  select(recipe,carbohydrate,sugar,protein,ends_with(".x"))
```



# For full,right and left joins i am using some dummy datasets that i created

## setting up the data

```{r}
# read in example csv files (join_df1 and join_df2)
join_df1 <- read.csv("join_df1.csv") |> 
  rename(A=`ï..A`)
join_df2 <- read.csv("join_df2.csv")|> 
  rename(A=`ï..A`)

join<-dbConnect(RSQLite::SQLite(), ":memory:")
copy_to(join,join_df1)
copy_to(join,join_df2)
```

## look at the databases now

```{r}
dbGetQuery(join,"SELECT * FROM join_df1")
```

```{r}
dbGetQuery(join,"SELECT * FROM join_df2")
```

## left join in SQL

### Left Join

For a left join, all rows in the first table specified will be included in the output. Any row in the second table that is *not* in the first table will not be included. 

```{r}
dbGetQuery(join,"SELECT * 
                 FROM join_df1
                 LEFT JOIN join_df2
                 USING(A)")
```

## RIGHT JOIN IN SQL

Right Join is similar to what we just discussed; however, in the output from a right join, all rows in the final table specified are included in the output. NAs will be included for any observations found in the last specified table but not in the other tables.


```{r}
dbGetQuery(join,"SELECT * 
                 FROM join_df1
                 RIGHT JOIN join_df2
                 USING(A)")
```



# left join df1 and df2
```{r}
dplyr::left_join(join_df1, join_df2,by = join_by(A))
```


# right join df1 and df2
```{r}
dplyr::right_join(join_df1, join_df2,by = join_by(A))
```

## full join in SQL

Finally, a full join will take every observation from every table and include it in the output.


```{r}
dbGetQuery(join,"SELECT * FROM join_df1 
                 FULL JOIN join_df2
                 USING(A)")
```


## full join df1 and df2 specifying which column is the same

```{r}
dplyr::full_join(join_df1, join_df2,by = join_by(A))
```








